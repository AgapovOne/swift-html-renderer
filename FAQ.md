# SwiftHTMLRenderer — FAQ по решениям

## Архитектура

### Почему два отдельных модуля (Parser и Renderer)?

Парсер полезен без рендерера: анализ HTML, извлечение данных, трансформация дерева. Рендерер полезен без парсера: можно собрать AST вручную. Разделение позволяет использовать только нужную часть и снижает связанность.

### Почему AST публичный и модифицируемый?

Пользователь может захотеть: убрать элементы перед рендерингом, добавить обёртки, собрать аналитику, трансформировать дерево. Закрытый AST заставляет дублировать парсинг на стороне пользователя.

## Парсинг

### Почему best-effort парсинг, а не strict?

HTML из API и CMS часто невалидный. Strict-парсинг отказал бы в рендеринге большей части реального контента. Браузеры работают так же — восстанавливаются при ошибках. При этом диагностики возвращаются вместе с результатом, чтобы пользователь знал о проблемах.

### Почему парсинг только целого документа, без стриминга?

Основной сценарий — rich-text из API: статьи, комментарии, документация. Это небольшие документы, которые приходят целиком. Стриминг усложняет реализацию и API. Если понадобится — добавим позже.

### Почему полная поддержка HTML entities сразу?

Entities встречаются повсеместно: `&amp;`, `&nbsp;`, эмодзи через `&#x1F600;`. Без их поддержки парсер выдаёт мусор вместо текста. Это базовая функция парсера, не опциональная.

## Рендеринг

### Почему три уровня кастомизации?

Разные задачи — разная глубина контроля:

- **Style config** — быстро поменять шрифт заголовка. Не нужно писать View.
- **ViewBuilder closures** — кастомный вид для конкретного элемента. SwiftUI-идиоматично.
- **Visitor protocol** — полный контроль обхода. Для нестандартных сценариев: аналитика, трансформация.

Один уровень не покрывает все случаи. Три уровня закрывают спектр от «поменять цвет» до «полностью свой рендеринг».

### Почему ViewBuilder closures, а не только protocol?

SwiftUI-разработчики привыкли к ViewBuilder-паттерну (как в `List`, `ForEach`). Closures проще для типичного кейса «переопределить один элемент». Protocol нужен для редких случаев, когда важен полный обход дерева.

### Почему ссылки через callback, а не открытие в браузере по умолчанию?

Библиотека не знает контекст: может быть deeplink, внутренняя навигация, или нужно показать preview. Дефолтное открытие Safari — навязывание поведения. Callback отдаёт решение пользователю.

### Почему callback для неизвестных элементов?

HTML развивается, пользователи могут использовать кастомные теги. Полное игнорирование теряет контент. Callback позволяет пользователю решить: рендерить, пропустить, или отрисовать детей.

### Почему дефолт для неизвестных элементов — рендерить детей, а не пропускать?

`<article>`, `<section>`, `<main>` — частые теги в реальном HTML. Если пропускать их вместе с детьми — пропадёт весь контент. Безопасный дефолт: пропустить тег-обёртку, отрендерить содержимое.

### Почему ссылки без callback рендерятся как стилизованный, но некликабельный текст?

Библиотека не знает, как обрабатывать URL. Молча открывать Safari — навязывание. Рендерить как обычный текст — теряется визуальная информация. Стилизованный некликабельный текст — компромисс: пользователь видит, что это ссылка, но ничего не сломается.

### Почему ViewBuilder приоритетнее Style config?

ViewBuilder даёт полный контроль — пользователь намеренно переопределяет рендеринг. Style config — лёгкая настройка. Если задано и то и другое, логично что более точная инструкция побеждает. Visitor protocol заменяет весь пайплайн и не комбинируется с остальными — это осознанный выбор «сделать всё самому».

### Почему Visitor protocol generic, а не возвращает View?

Первая версия спеки показывала Visitor с `some View`. Это делало его копией ViewBuilder closures. Visitor — общий механизм обхода дерева. С `associatedtype Result` он работает для рендеринга, аналитики, экспорта, трансформации. Разделение ответственности: ViewBuilder = кастомный рендер элемента, Visitor = произвольный обход AST.

### Почему все HTML-атрибуты сохраняются в словаре?

Библиотека не знает, какие атрибуты нужны пользователю. `data-*` атрибуты, `class`, `id` — могут использоваться для бизнес-логики. `style` сохраняется как сырая строка на случай, если пользователь захочет парсить CSS сам. Фильтрация атрибутов теряет информацию без выигрыша.

### Почему парсер схлопывает пробелы?

HTML-спецификация требует этого. Без схлопывания каждый перенос строки в исходном HTML превращается в видимый пробел. Текст выглядит поломанным. Это не опциональная фича — базовое поведение HTML-парсера.

## Scope v1

### Почему текст + списки + таблицы, но без картинок?

Таблицы критичны для документации и структурированного контента. Картинки требуют отдельных решений: кеширование, placeholder, ресайз, async-загрузка. Это отдельная фича, не блокирующая основной рендеринг.

### Почему без CSS в v1?

CSS — сложный отдельный парсер с каскадом, специфичностью, наследованием. Для rich-text контента достаточно HTML-семантики и кастомизации через три уровня. CSS добавляет ценность для полных веб-страниц, а это не наш сценарий.

### Почему HTML5 semantic containers (article, section, nav...) в v1?

Реальный HTML из CMS и API почти всегда использует `<article>`, `<section>`, `<main>`. Без их поддержки весь контент внутри этих тегов попадает в «unknown elements». Рендеринг прост — они ведут себя как `<div>`. Стоимость добавления минимальна, а без них библиотека бесполезна на реальных данных.

### Почему таблицы в v1 ограничены — без colspan/rowspan?

Полная поддержка таблиц в SwiftUI требует расчёта ширины колонок с учётом spanning, что сильно усложняет реализацию. Простые таблицы покрывают большинство случаев: прайс-листы, сравнения, данные из API. colspan/rowspan — отдельная задача для следующих версий.

### Почему без blockquote, code/pre в v1?

Приоритет — базовые элементы, которые встречаются в любом контенте. Blockquote и code важны, но добавить их позже просто: архитектура с visitor/ViewBuilder позволяет расширять набор элементов без ломающих изменений.

### Почему read-only, без интерактивности?

Основной сценарий — отображение контента. Формы и инпуты — это другой уровень сложности: валидация, состояние, отправка данных. Не нужны для статей, документации, комментариев.

## Платформа

### Почему iOS 17+?

iOS 17 даёт доступ к современным SwiftUI API без ограничений старых версий. Баланс между охватом устройств и возможностями фреймворка. Конкретный набор платформ определим при исследовании технической реализации.

### Почему только iOS, без macOS?

Начинаем с одной платформы, чтобы не усложнять первую версию. SwiftUI кроссплатформенный — расширение на macOS и другие платформы будет несложным, когда ядро стабилизируется.

## Accessibility

### Почему базовый маппинг, а не полный?

Полный маппинг требует глубокой работы с ARIA-атрибутами и семантикой. Базовый (headings, links, lists) покрывает главные сценарии и не требует много кода. Пользователь доработает через кастомные рендереры.
