{
  "project": "SwiftHTMLRenderer",
  "branchName": "ralph/renderer",
  "description": "Renderer Module — AST to SwiftUI views with three levels of customization",
  "userStories": [
    {
      "id": "US-001",
      "title": "Add HTMLRenderer module to SPM package",
      "description": "As a library developer, I want to add an HTMLRenderer Swift module to the SPM package so that users can import it separately from HTMLParser.",
      "acceptanceCriteria": [
        "Package.swift has a new target HTMLRenderer in Sources/HTMLRenderer/ that depends on HTMLParser",
        "Package.swift has a new product HTMLRenderer exporting the HTMLRenderer target",
        "Package.swift has a new test target HTMLRendererTests in Tests/HTMLRendererTests/ that depends on HTMLRenderer",
        "HTMLRenderer target can import SwiftUI and HTMLParser",
        "Create a placeholder HTMLView.swift in Sources/HTMLRenderer/ with: public struct HTMLView: View { public var body: some View { EmptyView() } }",
        "Create a placeholder test in Tests/HTMLRendererTests/ that imports HTMLRenderer",
        "swift build passes",
        "swift test passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Add the HTMLRenderer target alongside existing HTMLParser target. HTMLRenderer depends on HTMLParser (for AST types) but NOT on CGumbo. The existing HTMLParser, CGumbo, HTMLParserTests, and HTMLParserBenchmarks targets must remain unchanged. Platform is iOS 17+ and macOS 14+ (already in Package.swift)."
    },
    {
      "id": "US-002",
      "title": "Implement HTMLView and core text rendering",
      "description": "As a library user, I want to render HTML text content as SwiftUI views so I can display rich text from APIs.",
      "acceptanceCriteria": [
        "HTMLView(document: HTMLDocument) initializer that renders the document's children",
        "HTMLView(html: String) convenience initializer that calls HTMLParser.parseFragment() internally and renders the result",
        "Internal recursive NodeRenderer view that switches on HTMLNode cases (.element, .text, .comment)",
        ".text(String) nodes render as SwiftUI Text",
        ".comment nodes are skipped (not rendered)",
        "Unknown/unsupported elements render their children (skip the tag, keep content)",
        "<p> renders as Text with .body font",
        "<h1> through <h6> render as Text with fonts: .largeTitle, .title, .title2, .title3, .headline, .subheadline",
        "<b> and <strong> render with .bold() modifier",
        "<i> and <em> render with .italic() modifier",
        "<u> renders with .underline() modifier",
        "<s> and <del> render with .strikethrough() modifier",
        "<code> renders with monospaced .body font (.monospaced())",
        "<span> renders children without additional styling",
        "<br> renders as a newline (Text(\"\\n\"))",
        "<sub> and <sup> render with .baselineOffset() (negative for sub, positive for sup) and smaller font",
        "swift build passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "This is the core rendering pipeline. NodeRenderer should be a private/internal SwiftUI View that takes an HTMLNode and recursively renders it. For elements, switch on element.tagName to choose rendering. Use VStack(alignment: .leading, spacing: 8) to lay out block-level children. Each inline element wraps its children's text with appropriate modifiers. The HTMLView should hold the HTMLDocument as a stored property. Import HTMLParser for AST types."
    },
    {
      "id": "US-003",
      "title": "Implement block element rendering",
      "description": "As a library user, I want to see lists, blockquotes, code blocks and semantic containers rendered correctly.",
      "acceptanceCriteria": [
        "<div> renders children in VStack(alignment: .leading)",
        "Semantic containers (<article>, <section>, <main>, <header>, <footer>, <nav>, <aside>) render identically to <div>",
        "<blockquote> renders with leading padding and a vertical accent-colored bar on the left side (overlay or border)",
        "<pre> renders with monospaced font, preserves whitespace, light gray background with corner radius",
        "<hr> renders as Divider()",
        "<figure> renders children in VStack, <figcaption> renders with .caption font and .secondary foreground color",
        "<ul> renders as VStack where each <li> child has a bullet character (•) prefix in an HStack",
        "<ol> renders as VStack where each <li> child has a numbered prefix (1., 2., ...) in an HStack",
        "<li> renders its children (text and nested elements)",
        "swift build passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "For lists: use ForEach with enumerated children to get the index for <ol> numbering. Filter li elements from the ul/ol children. For blockquote: use .padding(.leading, 16) and overlay a Rectangle().frame(width: 3) aligned to .leading with .accent color. For <pre>: wrap in a container with .font(.system(.body, design: .monospaced)) and .padding() and .background(Color.gray.opacity(0.1)) with .clipShape(RoundedRectangle(cornerRadius: 8))."
    },
    {
      "id": "US-004",
      "title": "Implement table rendering via Grid",
      "description": "As a library user, I want to display simple HTML tables using SwiftUI Grid.",
      "acceptanceCriteria": [
        "<table> renders using SwiftUI Grid with alignment: .leading",
        "<thead>, <tbody>, <tfoot> are structural wrappers — they pass through their <tr> children to the Grid",
        "<tr> renders as GridRow",
        "<th> renders cell content with bold font",
        "<td> renders cell content with regular font",
        "Table with 2+ rows and 2+ columns displays correctly",
        "colspan and rowspan attributes are ignored (not supported in v1)",
        "swift build passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "SwiftUI Grid requires GridRow children directly — cannot nest them inside other views. So when rendering <table>, collect ALL <tr> elements from thead/tbody/tfoot children (flatten the structural wrappers) and emit GridRow for each <tr>. Each GridRow contains the rendered <td>/<th> cells. Use .gridCellColumns(1) as default. Gumbo always inserts implicit <tbody>, so a simple <table><tr><td> becomes table > tbody > tr > td in the AST."
    },
    {
      "id": "US-005",
      "title": "Implement links and unknown element handling",
      "description": "As a library user, I want links to be tappable via callback and unknown elements to gracefully show their content.",
      "acceptanceCriteria": [
        "HTMLView(document:, onLinkTap:) accepts an optional closure (URL) -> Void for link taps",
        "HTMLView(html:, onLinkTap:) convenience also accepts the closure",
        "<a href=\"...\"> without onLinkTap renders as styled text: underline + .blue foreground color, not tappable",
        "<a href=\"...\"> with onLinkTap renders as Button that calls the closure with the URL from href attribute",
        "If href is missing or not a valid URL, link renders as plain styled text even with callback",
        "HTMLView(document:, onUnknownElement:) accepts optional closure (HTMLElement) -> AnyView for unknown elements",
        "Without onUnknownElement callback, unknown tags skip the tag and render children",
        "With onUnknownElement callback, the closure is called and its returned view is used instead",
        "swift build passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": "Pass onLinkTap and onUnknownElement through the view hierarchy via SwiftUI Environment or as parameters to NodeRenderer. URL(string:) may return nil for invalid URLs — handle gracefully. For the link Button, use .buttonStyle(.plain) to avoid default button chrome, then apply the underline + blue styling manually."
    },
    {
      "id": "US-006",
      "title": "Implement HTMLStyleConfiguration",
      "description": "As a library user, I want to customize fonts, colors and spacing for each element type without writing custom views.",
      "acceptanceCriteria": [
        "HTMLStyleConfiguration is a public struct with element style groups",
        "Each group (HTMLElementStyle) has optional properties: font: Font?, foregroundColor: Color?, backgroundColor: Color?, padding: EdgeInsets?, lineSpacing: CGFloat?",
        "Groups: heading1 through heading6, paragraph, bold, italic, underline, strikethrough, code, preformatted, blockquote, link, listItem, tableHeader, tableCell",
        "HTMLStyleConfiguration.default static property returns configuration with sensible defaults matching the existing hardcoded styles",
        "HTMLView(document:, configuration:) accepts a configuration",
        "HTMLView(html:, configuration:) convenience also accepts configuration",
        "When a property is nil in the configuration, the default value is used (nil means 'use default')",
        "Configuration overrides the hardcoded defaults in renderers for the corresponding elements",
        "swift build passes"
      ],
      "priority": 6,
      "passes": true,
      "notes": "Pass the configuration through the view hierarchy via SwiftUI @Environment or as a parameter to NodeRenderer. HTMLElementStyle should be a simple struct with all-optional properties. The renderers should check configuration first, fall back to hardcoded defaults. Keep HTMLStyleConfiguration.default as a static let that mirrors the hardcoded styles from US-002 and US-003."
    },
    {
      "id": "US-007",
      "title": "Implement ViewBuilder closures with marker types",
      "description": "As a library user, I want to replace the rendering of specific elements with my own SwiftUI views using a SwiftUI-idiomatic API.",
      "acceptanceCriteria": [
        "Marker types as public structs: HTMLHeadingRenderer, HTMLParagraphRenderer, HTMLLinkRenderer, HTMLListRenderer, HTMLListItemRenderer, HTMLBlockquoteRenderer, HTMLCodeBlockRenderer, HTMLTableRenderer",
        "Each marker type holds a closure that receives element content/children and attributes and returns some View",
        "HTMLHeadingRenderer closure signature: (children: [HTMLNode], level: Int, attributes: [String: String]) -> some View",
        "HTMLLinkRenderer closure signature: (children: [HTMLNode], href: String?, attributes: [String: String]) -> some View",
        "Other markers: (children: [HTMLNode], attributes: [String: String]) -> some View",
        "@HTMLContentBuilder result builder that collects marker type instances into an HTMLCustomRenderers struct",
        "HTMLView(html:, @HTMLContentBuilder content: () -> HTMLCustomRenderers) initializer",
        "HTMLView(document:, @HTMLContentBuilder content: () -> HTMLCustomRenderers) initializer",
        "ViewBuilder closure takes priority over Style Configuration when both are set for the same element",
        "Elements without a custom closure use Style Configuration or defaults",
        "swift build passes"
      ],
      "priority": 7,
      "passes": true,
      "notes": "The result builder pattern: @resultBuilder struct HTMLContentBuilder { static func buildBlock(_ components: ...) -> HTMLCustomRenderers }. HTMLCustomRenderers is an internal struct that holds optional closures for each element type. Each marker type conforms to a common protocol (e.g. HTMLRendererComponent) that the builder uses. The rendering pipeline checks: custom renderer first, then style config, then default. Use @ViewBuilder and AnyView to type-erase the custom closures."
    },
    {
      "id": "US-008",
      "title": "Implement HTMLVisitor protocol",
      "description": "As a library user, I want to traverse the AST with a visitor pattern to implement custom rendering, analytics, or export logic.",
      "acceptanceCriteria": [
        "HTMLVisitor is a public protocol with associatedtype Result",
        "Per-tag methods: visitHeading(_:level:) -> Result, visitParagraph(_:) -> Result, visitLink(_:href:) -> Result, visitList(_:ordered:) -> Result, visitListItem(_:) -> Result, visitBlockquote(_:) -> Result, visitCodeBlock(_:) -> Result, visitTable(_:) -> Result, visitHorizontalRule() -> Result, visitText(_:) -> Result, visitComment(_:) -> Result",
        "visitElement(_: HTMLElement) -> Result as fallback for unknown/unhandled elements",
        "Default implementations via protocol extension: all per-tag methods delegate to visitElement(_:)",
        "Default visitElement returns an empty/default Result where possible",
        "HTMLDocument.accept<V: HTMLVisitor>(visitor: V) -> [V.Result] — walks all top-level children",
        "HTMLNode.accept<V: HTMLVisitor>(visitor: V) -> V.Result — dispatches to the correct visitor method based on tagName",
        "HTMLVisitor protocol lives in the HTMLParser module (not HTMLRenderer) since it operates on AST types and has no SwiftUI dependency",
        "swift build passes"
      ],
      "priority": 8,
      "passes": true,
      "notes": "The visitor belongs in HTMLParser module because it only uses AST types (HTMLDocument, HTMLNode, HTMLElement) and has no SwiftUI dependency. The accept() method on HTMLNode does the tagName dispatch: switch element.tagName { case 'h1'...'h6': visitor.visitHeading(element, level: n) case 'p': visitor.visitParagraph(element) case 'a': visitor.visitLink(element, href: element.attributes['href']) ... default: visitor.visitElement(element) }. For Result types like [String] or String, users can concatenate. For optional Result types, return nil as default."
    },
    {
      "id": "US-009",
      "title": "Add renderer tests",
      "description": "As a library developer, I want tests covering the renderer, style configuration, ViewBuilder closures, and visitor protocol.",
      "acceptanceCriteria": [
        "Test target HTMLRendererTests in Tests/HTMLRendererTests/",
        "Test: HTMLView(html: \"<h1>Title</h1>\") instantiates without crash",
        "Test: HTMLView(html:) for each supported element type (p, h1-h6, b, i, u, s, ul, ol, table, blockquote, pre, hr, a, div, code) instantiates without crash",
        "Test: HTMLView(document:) with manually constructed HTMLDocument works",
        "Test: empty HTMLDocument renders without crash",
        "Test: nested elements <div><p><b>text</b></p></div> renders without crash",
        "Test: unknown element <custom>content</custom> renders children without crash",
        "Test: HTMLStyleConfiguration.default has non-nil values for heading1 font",
        "Test: HTMLVisitor — a concrete visitor that collects all text nodes returns correct strings",
        "Test: HTMLVisitor — visitHeading is called for h1 elements with level 1",
        "Test: HTMLDocument.accept(visitor:) returns array of results",
        "swift test passes"
      ],
      "priority": 9,
      "passes": true,
      "notes": "SwiftUI views cannot be easily inspected in unit tests. Use ViewInspector-style approach only if available, otherwise test that views instantiate without crashing. For visitor tests: create a TextCollectorVisitor that conforms to HTMLVisitor with Result = String?, returns the text for visitText and nil for everything else. Parse '<p>Hello <b>world</b></p>' and verify the visitor collects ['Hello ', 'world']. Use Swift Testing @Test macro."
    }
  ]
}
