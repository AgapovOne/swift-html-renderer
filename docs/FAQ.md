# SwiftHTMLRenderer — FAQ по решениям

## Архитектура

### Почему два отдельных модуля (Parser и Renderer)?

Парсер полезен без рендерера: анализ HTML, извлечение данных, трансформация дерева. Рендерер полезен без парсера: можно собрать AST вручную. Разделение позволяет использовать только нужную часть и снижает связанность.

### Почему AST публичный?

Пользователь может захотеть: убрать элементы перед рендерингом, добавить обёртки, собрать аналитику, трансформировать дерево. Закрытый AST заставляет дублировать парсинг на стороне пользователя.

### Почему AST immutable (value types), а не mutable (classes)?

Три причины:
1. **SwiftUI diffing** — Equatable structs позволяют SwiftUI понять, изменился ли контент, без пересоздания views.
2. **Thread safety** — value types безопасны между потоками без синхронизации. Парсинг в бэкграунде, рендеринг на main thread — без data races.
3. **Кеширование** — Hashable AST можно кешировать по хешу HTML-строки.

Модификация = создание нового дерева. Дороже, чем in-place мутация, но для наших размеров документов (< 50 KB) разница незаметна.

## Парсинг

### Почему сторонний парсер, а не свой?

Spec-compliant HTML5 парсер — отдельный проект на месяцы: void elements, optional closing tags, nesting rules, content model, entity decoding, whitespace normalization, error recovery. Наша ценность — SwiftUI-рендеринг и API кастомизации, не парсинг. Сторонняя библиотека даёт spec compliance бесплатно. Наш модуль Parser — обёртка, конвертирующая результат в наш AST.

### Почему парсинг только целого документа, без стриминга?

Основной сценарий — rich-text из API: статьи, комментарии, документация. Это небольшие документы, которые приходят целиком. Стриминг усложняет API. Если понадобится — добавим позже.

### Почему threading и кеширование — ответственность пользователя?

Библиотека — инструмент, не фреймворк. Она не знает контекст: может быть SwiftUI, может UIKit, может серверный Swift. Управление потоками и кешем зависит от архитектуры приложения. Парсер синхронный и thread-safe — пользователь вызывает откуда удобно. Immutable Hashable AST делает кеширование тривиальным.

### Почему нет абсолютных целевых показателей парсинга?

Абсолютные цифры до первых замеров — гадание. Главный критерий: быстрее NSAttributedString(html:). После первых замеров зафиксируем конкретные цифры как baseline для регрессий.

## Рендеринг

### Почему три уровня кастомизации?

Разные задачи — разная глубина контроля:

- **Style config** — быстро поменять шрифт заголовка. Не нужно писать View.
- **ViewBuilder closures** — кастомный вид для конкретного элемента. SwiftUI-идиоматично.
- **Visitor protocol** — полный контроль обхода. Для нестандартных сценариев: аналитика, трансформация.

Один уровень не покрывает все случаи. Три уровня закрывают спектр от «поменять цвет» до «полностью свой рендеринг».

### Почему гибридная стратегия рендеринга inline-элементов?

По умолчанию inline-элементы (bold, italic, links) схлопываются в один SwiftUI view. Это минимизирует view count и ускоряет layout — критично для 120fps. Если пользователь задаёт ViewBuilder для inline-элемента — блок переключается на отдельные views. Компромисс: производительность по умолчанию, гибкость при необходимости.

ViewBuilder для inline-элементов — осознанный trade-off. Пользователь получает гибкость, но теряет схлопывание в этом блоке.

### Почему ViewBuilder closures, а не только protocol?

SwiftUI-разработчики привыкли к ViewBuilder-паттерну (как в `List`, `ForEach`). Closures проще для типичного кейса «переопределить один элемент». Protocol нужен для редких случаев, когда важен полный обход дерева.

### Почему ссылки через callback, а не открытие в браузере по умолчанию?

Библиотека не знает контекст: может быть deeplink, внутренняя навигация, или нужно показать preview. Дефолтное открытие Safari — навязывание поведения. Callback отдаёт решение пользователю.

### Почему callback для неизвестных элементов?

HTML развивается, пользователи могут использовать кастомные теги. Полное игнорирование теряет контент. Callback позволяет пользователю решить: рендерить, пропустить, или отрисовать детей.

### Почему дефолт для неизвестных элементов — рендерить детей, а не пропускать?

`<article>`, `<section>`, `<main>` — частые теги в реальном HTML. Если пропускать их вместе с детьми — пропадёт весь контент. Безопасный дефолт: пропустить тег-обёртку, отрендерить содержимое.

### Почему ссылки без callback рендерятся как стилизованный, но некликабельный текст?

Библиотека не знает, как обрабатывать URL. Молча открывать Safari — навязывание. Рендерить как обычный текст — теряется визуальная информация. Стилизованный некликабельный текст — компромисс: пользователь видит, что это ссылка, но ничего не сломается.

### Почему ViewBuilder приоритетнее Style config?

ViewBuilder даёт полный контроль — пользователь намеренно переопределяет рендеринг. Style config — лёгкая настройка. Если задано и то и другое, логично что более точная инструкция побеждает. Visitor protocol заменяет весь пайплайн и не комбинируется с остальными — это осознанный выбор «сделать всё самому».

### Почему Visitor protocol generic, а не возвращает View?

Первая версия спеки показывала Visitor с `some View`. Это делало его копией ViewBuilder closures. Visitor — общий механизм обхода дерева. С `associatedtype Result` он работает для рендеринга, аналитики, экспорта, трансформации. Разделение ответственности: ViewBuilder = кастомный рендер элемента, Visitor = произвольный обход AST.

### Почему все HTML-атрибуты сохраняются в словаре?

Библиотека не знает, какие атрибуты нужны пользователю. `data-*` атрибуты, `class`, `id` — могут использоваться для бизнес-логики. Фильтрация атрибутов теряет информацию без выигрыша. `style` сохраняется как сырая строка — библиотека его не парсит. Boolean-атрибуты нормализуются к `["disabled": "disabled"]` по HTML-спецификации.

### Почему AST хранит нормализованные данные?

Сторонний парсер отдаёт нормализованный результат (whitespace, case, entities). Мы конвертируем его в наш AST как есть. Рендерер получает чистые данные и не думает о нюансах HTML-спецификации.

## Scope v1

### Почему текст + списки + таблицы, но без картинок?

Таблицы критичны для документации и структурированного контента. Картинки требуют отдельных решений: кеширование, placeholder, ресайз, async-загрузка. Это отдельная фича, не блокирующая основной рендеринг.

### Почему без CSS в v1?

CSS — сложный отдельный парсер с каскадом, специфичностью, наследованием. Для rich-text контента достаточно HTML-семантики и кастомизации через три уровня. CSS добавляет ценность для полных веб-страниц, а это не наш сценарий.

### Почему HTML5 semantic containers (article, section, nav...) в v1?

Реальный HTML из CMS и API почти всегда использует `<article>`, `<section>`, `<main>`. Без их поддержки весь контент внутри этих тегов попадает в «unknown elements». Рендеринг прост — они ведут себя как `<div>`. Стоимость добавления минимальна, а без них библиотека бесполезна на реальных данных.

### Почему таблицы в v1 ограничены — без colspan/rowspan?

Полная поддержка таблиц в SwiftUI требует расчёта ширины колонок с учётом spanning, что сильно усложняет реализацию. Простые таблицы покрывают большинство случаев: прайс-листы, сравнения, данные из API. colspan/rowspan — отдельная задача для следующих версий.

### Почему code/blockquote добавили в v1?

Первоначально откладывали на потом. Ревью показал: `<code>` и `<blockquote>` встречаются в документации и CMS-контенте чаще таблиц. Рендеринг тривиальный (шрифт + фон для code, отступ + полоска для blockquote). Риск для timeline минимальный, покрытие реального контента значительно выше.

### Почему read-only, без интерактивности?

Основной сценарий — отображение контента. Формы и инпуты — это другой уровень сложности: валидация, состояние, отправка данных. Не нужны для статей, документации, комментариев.

## Платформа

### Почему iOS 17+?

iOS 17 даёт доступ к современным SwiftUI API без ограничений старых версий. Баланс между охватом устройств и возможностями фреймворка. Конкретный набор платформ определим при исследовании технической реализации.

### Почему только iOS, без macOS?

Начинаем с одной платформы, чтобы не усложнять первую версию. SwiftUI кроссплатформенный — расширение на macOS и другие платформы будет несложным, когда ядро стабилизируется.

## Images

### Почему `<img>` ломает inline collapsing?

В v1 `<img>` внутри phrasing-контекста (`<p>text <img> text</p>`) переключает блок на separate views. Inline collapsing строит один `Text`, а SwiftUI `Text` поддерживает только синхронный `Image` через интерполяцию (`Text("\(Image(...))")`). `AsyncImage` встроить в `Text` нельзя.

Три варианта на будущее:

1. **Синхронный image provider.** Пользователь передаёт `(URL) -> Image?`. Если картинка в кеше — встраиваем в `Text`. Если нет — fallback на separate views. Подходит для иконок и предзагруженных картинок.
2. **Двухфазный рендеринг.** Первый проход: inline text без картинки + placeholder. Второй проход: после загрузки пересобираем `Text` с `Image`. Сложнее, но полностью async.
3. **HStack с фрагментами текста.** Разбить текст вокруг `<img>` на куски, обернуть в `HStack`. Минус: текст не переносится единым потоком.

Для v1 выбран простой подход: `<img>` ломает collapsing. В 90% случаев картинки стоят отдельным блоком. Inline-иконки — редкий кейс, решается через кастомный ViewBuilder.

## Accessibility

### Почему базовый маппинг, а не полный?

Полный маппинг требует глубокой работы с ARIA-атрибутами и семантикой. Базовый (headings, links, lists) покрывает главные сценарии и не требует много кода. Пользователь доработает через кастомные рендереры.
