# SwiftHTMLRenderer — FAQ по решениям

## Архитектура

### Почему AST публичный?

Пользователь может захотеть: убрать элементы перед рендерингом, добавить обёртки, собрать аналитику, трансформировать дерево. Закрытый AST заставляет дублировать парсинг на стороне пользователя.

### Почему AST immutable (value types), а не mutable (classes)?

Три причины:
1. **SwiftUI diffing** — Equatable structs позволяют SwiftUI понять, изменился ли контент, без пересоздания views.
2. **Thread safety** — value types безопасны между потоками без синхронизации. Парсинг в бэкграунде, рендеринг на main thread — без data races.
3. **Кеширование** — Hashable AST можно кешировать по хешу HTML-строки.

Модификация = создание нового дерева. Дороже, чем in-place мутация, но для наших размеров документов (< 50 KB) разница незаметна.

## Рендеринг

### Почему два уровня кастомизации?

Разные задачи — разная глубина контроля:

- **ViewBuilder closures** — кастомный вид для конкретного элемента. SwiftUI-идиоматично, привычно.
- **Visitor protocol** — полный контроль обхода AST. Для нестандартных сценариев: аналитика, трансформация, экспорт.

Один уровень не покрывает все случаи. Два уровня закрывают спектр от «переопределить один элемент» до «полностью свой обход дерева».

### Почему гибридная стратегия рендеринга inline-элементов?

По умолчанию inline-элементы (bold, italic, links) схлопываются в один SwiftUI view. Это минимизирует view count и ускоряет layout — критично для 120fps. Если пользователь задаёт ViewBuilder для inline-элемента — блок переключается на отдельные views. Компромисс: производительность по умолчанию, гибкость при необходимости.

ViewBuilder для inline-элементов — осознанный trade-off. Пользователь получает гибкость, но теряет схлопывание в этом блоке.

### Почему tag-based система (htmlTag / htmlTagInlineText / htmlSkipTag)?

Named renderers покрывают встроенные элементы. Но HTML из CMS может содержать кастомные теги или теги, которые библиотека не поддерживает. Tag-based система закрывает этот gap:

- **htmlTag** — рендерить произвольный тег кастомным View
- **htmlTagInlineText** — трансформировать Text внутри inline collapsing (без потери производительности)
- **htmlSkipTag** — пропустить тег, отрендерить только детей

Три варианта нужны, потому что block View ломает inline collapsing, а inline-only трансформация не даёт полного контроля. Пользователь выбирает подходящий вариант.

### Почему ViewBuilder closures, а не только protocol?

SwiftUI-разработчики привыкли к ViewBuilder-паттерну (как в `List`, `ForEach`). Closures проще для типичного кейса «переопределить один элемент». Protocol нужен для редких случаев, когда важен полный обход дерева.

### Почему приоритет: named > tag > built-in > unknown?

Named renderer — пользователь явно переопределяет конкретный элемент. Tag renderer — переопределение по имени тега. Built-in — дефолт. Unknown — fallback. Каждый следующий уровень менее специфичен. Более точная инструкция побеждает.

### Почему ссылки кликабельны всегда?

Ссылки работают через `onLinkTap` callback или стандартный `OpenURLAction` из SwiftUI environment. Если пользователь не передал callback — ссылка открывается через системный механизм. Некликабельная ссылка — плохой UX: пользователь видит синий подчёркнутый текст, нажимает, ничего не происходит.

### Почему callback для неизвестных элементов?

HTML развивается, пользователи могут использовать кастомные теги. Полное игнорирование теряет контент. Callback позволяет пользователю решить: рендерить, пропустить, или отрисовать детей.

### Почему дефолт для неизвестных элементов — рендерить детей, а не пропускать?

`<article>`, `<section>`, `<main>` — частые теги в реальном HTML. Если пропускать их вместе с детьми — пропадёт весь контент. Безопасный дефолт: пропустить тег-обёртку, отрендерить содержимое.

### Почему все HTML-атрибуты сохраняются в словаре?

Библиотека не знает, какие атрибуты нужны пользователю. `data-*` атрибуты, `class`, `id` — могут использоваться для бизнес-логики. Фильтрация атрибутов теряет информацию без выигрыша. `style` сохраняется как сырая строка — библиотека его не парсит. Boolean-атрибуты нормализуются к `["disabled": "disabled"]` по HTML-спецификации.

## Scope v1

### Почему текст + списки + таблицы, но без картинок?

Таблицы критичны для документации и структурированного контента. Картинки требуют отдельных решений: кеширование, placeholder, ресайз, async-загрузка. Это отдельная фича, не блокирующая основной рендеринг.

### Почему без CSS в v1?

CSS — сложный отдельный парсер с каскадом, специфичностью, наследованием. Для rich-text контента достаточно HTML-семантики и кастомизации через ViewBuilder closures. CSS добавляет ценность для полных веб-страниц, а это не наш сценарий.

### Почему HTML5 semantic containers (article, section, nav...) в v1?

Реальный HTML из CMS и API почти всегда использует `<article>`, `<section>`, `<main>`. Без их поддержки весь контент внутри этих тегов попадает в «unknown elements». Рендеринг прост — они ведут себя как `<div>`. Стоимость добавления минимальна, а без них библиотека бесполезна на реальных данных.

### Почему таблицы в v1 ограничены — без colspan/rowspan?

Полная поддержка таблиц в SwiftUI требует расчёта ширины колонок с учётом spanning, что сильно усложняет реализацию. Простые таблицы покрывают большинство случаев: прайс-листы, сравнения, данные из API. colspan/rowspan — отдельная задача для следующих версий.

### Почему code/blockquote добавили в v1?

Первоначально откладывали на потом. Ревью показал: `<code>` и `<blockquote>` встречаются в документации и CMS-контенте чаще таблиц. Рендеринг тривиальный (шрифт + фон для code, отступ + полоска для blockquote). Риск для timeline минимальный, покрытие реального контента значительно выше.

### Почему read-only, без интерактивности?

Основной сценарий — отображение контента. Формы и инпуты — это другой уровень сложности: валидация, состояние, отправка данных. Не нужны для статей, документации, комментариев.

## Платформа

### Почему iOS 17+?

iOS 17 даёт доступ к современным SwiftUI API без ограничений старых версий. Баланс между охватом устройств и возможностями фреймворка. Конкретный набор платформ определим при исследовании технической реализации.

### Почему только iOS, без macOS?

Начинаем с одной платформы, чтобы не усложнять первую версию. SwiftUI кроссплатформенный — расширение на macOS и другие платформы будет несложным, когда ядро стабилизируется.

## Images

### Почему `<img>` отложен на post-v1?

Попытка реализации выявила фундаментальные проблемы SwiftUI:

**AsyncImage нестабилен в глубоких иерархиях.** AsyncImage внутри ForEach > VStack > Environment > Group получает cancelled (`NSURLErrorDomain Code=-999`). Причина: SwiftUI пересоздаёт view при обновлении environment, AsyncImage начинает загрузку заново и предыдущий запрос отменяется. Замена на `@State` + `.task(id:)` с ручным `URLSession.shared.data(from:)` работает стабильнее, но усложняет код.

**Inline collapsing несовместим с async-картинками.** SwiftUI `Text` поддерживает синхронный `Image` через интерполяцию (`Text("\(Image(...))")`), но не `AsyncImage`. `<img>` внутри `<p>` ломает collapsing — блок переключается на separate views.

**Content jump при загрузке.** Картинка появляется с нулевой высотой, потом скачком принимает реальный размер. Варианты: `placeholderHeight` в стилях, атрибуты `width`/`height`, но ни один не идеален.

Три варианта реализации на будущее:

1. **Синхронный image provider.** Пользователь передаёт `(URL) -> Image?`. Если картинка в кеше — встраиваем в `Text`. Если нет — fallback на separate views.
2. **Двухфазный рендеринг.** Placeholder → загрузка → пересборка `Text` с `Image`.
3. **HStack с фрагментами текста.** Текст вокруг `<img>` разбивается на куски. Минус: текст не переносится единым потоком.

Вывод: `<img>` — отдельная фича, требующая продуманного API для image provider/cache. Не блокирует v1.

## Accessibility

### Почему базовый маппинг, а не полный?

Полный маппинг требует глубокой работы с ARIA-атрибутами и семантикой. Базовый (headings, links) покрывает главные сценарии и не требует много кода. Пользователь доработает через кастомные рендереры.
